\section{Neighborhood Encoding}

This section focuses on encoding methods that we can use to prune the search
space. In a similar vein to the way that GADDI~\cite{2009-EDBT-GADDI},
QuickSI~\cite{2008-VLDB-QuickSI}, and GraphQL~\cite{2008-SIGMOD-GraphQL} have
developed subgraph signatures that allow for the search space to be pruned, we
will extend, specifically, the notion of neighborhood subgraph profiles
(GraphQL) to include temporal information. First, lets present the notion of
Neighborhood Subgraphs~\cite{2008-SIGMOD-GraphQL}.

\begin{defn}
  (Neigborhood Subgraph) Given a static graph $G_s$, vertex $v$ and radius $r$,
  the $r$-neighborhood subgraph of vertex $v$, denoted $N(G,v,r)$, consists of
  all vertices within distance $r$ from $v$ and all edges between the
  vertices. Note that $N(G,v,0) = ({v}, \emptyset)$.
\end{defn}

This is a fairly basic notion that is easily extensible to consider temporal
information. The first requirement that will help us to prune the search space,
is to force these subgraphs to be contemporary under some condition $c \in \C$
So it is possible that a given static $r$-neighborhood subgraph is contemporary under the
given $c$, but that there are certain subgraphs of the static $r$-neighborhood
subgraph that are.  So our extension will return a set of subgraphs, not just a
single subgraph.

\begin{defn}
  (Temporal Neighborhood Subgraphs) Given a temporal graph $G$, a vertex $v$, a
  radius $r$, and a condition $c$, the Temporal Neighborhood Subgraph Set
  $N_c(G,v,r)$ of a vertex $v$ consists of those static neighborhood subgraphs
  that are concurrent under $c$. Note that $\displaystyle\bigcup N_c(G,v,r) =
  N(G,v,r)$.
\end{defn}

However, representing and using these temporal $r$-neighborhood subgraphs is
expensive, so we will condense these into a much more lightweight
\textit{profile}~\cite{2008-SIGMOD-GraphQL}. For static $r$-neighborhood
subgraphs, we simply lexographically order the labels on the vertices within the
set. Then, given a similar ordering of the vertices for the query graph $Q$, we
can prune the search space when the generated $r$-neighborhood subgraph of the
query graph is not a subsequence of the data graph profile.

For temporal $r$-neighborhood subgraphs, we have more information that we can
use to prune the search space. The \textit{temporal profile} of an
$r$-neighborhood subgraph will be a tuple $p = (p_s,p_t)$ of the static profile and
some temporal information. This temporal information will be an interval
constructed from the intervals on the edges of graph. We will henceforth refer
to $p_S$ as the semantic profile, and $p_t$ as the profile interval.

\begin{defn}
  Define $\tau_f$ to be a curried folding function $\tau_f : \C \to P(T^2) \to T^2$,
  that summarizes a set of time intervals in a single time interval dependent on
  the temporal semantics. The cases are defined below:

  \[
    \tau_f(c)(S) = \begin{cases}
      \bigcap S, & \text{ if } c = \textsc{concur}, \\
      \bigcup S, & otherwise      
    \end{cases}
  \]
  
\end{defn}

This definition makes sense, since any temporal query that obeys the
concurrent implicit temporal semantics will need to match the intersection of
all of the activity windows of the edges, where if the query obeys the weak or
strong consecutive semantics, we will approximate the behavior by taking the
union of all the edges, i.e. the minimum start time and the maximum end
time. This will allow us to prune grossly errant results.

\begin{defn}
  The temporal profile $p$ of a graph $G = (V,E)$, given some contemporaneity condition
  $c \in \C$, is defined to be a tuple $(p_s, p_t)_c$ where
  \begin{itemize}
  \item $p_S$ \emph{\texttt{:=} \, \texttt{toSortedList}} \; $\{L(v) | v \in V \}$,
    and
  \item $p_t$ \emph{\texttt{:=} \, \texttt{foldr1}} \; $\tau_f(c)$ \; $\{T(e) | e \in E\}$, where
    \texttt{foldr1} accumulates $\tau_f(c)$ accross the  given set, assuming the set
    is non-empty. If the set is empty then let $p_t$ be $(\infty,\infty)$.
  \end{itemize}

  Given two temporal profiles $p = (p_s, p_t)$ and $p' = (p'_s, p'_t)$, $p$ is
  said to contain $p'$ with respect to a condition $c$ (denoted $p' \subseteq_c
  p$) if $p'_s$ is a subseqence of $p_s$, and $c.p(p_t, p'_t)$.
\end{defn}

Once we have this information, we will compare the temporal $r$-neighborhood
profiles of the query graph and the data graph. The semantic condition will be
that the query semantic profile must be a subsequence of the data semantic
profile, where the interval condition will just be that the intersection must be
nonempty.  If there is no query interval specified, then we will consider the
interval to be $(\infty, \infty)$. This local refinement is defined in Algorithm
\ref{alg:loc_ref}.

\begin{algorithm}
  \label{alg:loc_ref}
  \caption{\textsc{LocalRefinement(Q,G,$\Phi$, $r$, $c$)}}
  \SetAlgoLined
  \KwIn{A query graph $Q$, data graph $G$, current candidate sets $\Phi$, a
    radius $r$}
  \KwOut{A refined set of $\Phi$}

  \ForEach{$u \in V(Q)$}{
    Calculate the temporal profile $p_Q$ of $N_c(Q,u,r)$\;
    \ForEach{$v \in \Phi(u)$}{
      Calculate the temporal profile $p_G$ of $N_c(G,v,r)$\;
      \If{$p_Q \not\subseteq p_G$}{
        remove $v$ from $\Phi(u)$\; 
      }
    }
  }
\end{algorithm}


This \textsc{LocalRefinement} procedure is a part of the
\textsc{FilterCandidates} procedure defined in Algorithm
\ref{alg:gen_query_proc}.


