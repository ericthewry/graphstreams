\section{Neighborhood Encoding}
\label{sec:encoding}

This section focuses on encoding methods that we can use to locally prune the
search space. The algorithm that will be developed here is an additional
subroutine that can be used in \textsc{FilterCandidates}. In a similar vein to
the way that GADDI~\cite{2009-EDBT-GADDI}, QuickSI~\cite{2008-VLDB-QuickSI}, and
GraphQL~\cite{2008-SIGMOD-GraphQL} have developed subgraph signatures that allow
for the search space to be pruned, we will extend, specifically, the notion of
neighborhood subgraph profiles (GraphQL) to include temporal information. First,
lets present the notion of Neighborhood Subgraphs~\cite{2008-SIGMOD-GraphQL}.

\begin{defn}
  (Neigborhood Subgraph) Given a static graph $G_s$, vertex $v$ and radius $r$,
  the $r$-neighborhood subgraph of vertex $v$, denoted $N(G,v,r)$, consists of
  all vertices within distance $r$ from $v$ and all edges between the
  vertices. Note that $N(G,v,0) = ({v}, \emptyset)$.
\end{defn}

This is a fairly basic notion that is easily extensible to consider temporal
information. The first requirement that will help us to prune the search space,
is to force these subgraphs to be contemporary under some condition $c \in \C$
So it is possible that a given static $r$-neighborhood subgraph is contemporary
under the given $c$, but that there are certain subgraphs of the static
$r$-neighborhood subgraph that are.  So the temporal extension must return a set
of subgraphs, not just a single subgraph. Since we are mapping edges instead of
vertices, we will define the temporal neighborhood subgraphs to be parameterized
on edges instead of on vertices.

\begin{defn}
  (Temporal Neighborhood Subgraphs) Given a temporal graph $G$, an edge $e =
  (u,v)$, a radius $r$, and a condition $c$, the temporal $r$-neighborhood
  subgraph set $N_c(G,e,r)$ of a vertex $e$ consists of the vertices and edges
  that are temporally reachable under $c$ in $r$ steps from $v$ and $u$. Note
  that $\displaystyle\bigcup N_c(G,e,r) = N(G,v,r) \cup N(G,u,r)$.
\end{defn}

However, representing and using these temporal $r$-neighborhood subgraphs is
expensive, so we will condense these into a much more lightweight
\textit{profile}~\cite{2008-SIGMOD-GraphQL}. For static $r$-neighborhood
subgraphs, we simply lexographically order the vertices on the edges within the
set. Then, given a similar ordering of the edges for the query graph $Q$, we
can prune the search space when the generated $r$-neighborhood subgraph of the
query graph is not a subsequence of the data graph profile. A significant
improvement to this original profile models \cite{2012-VDLP-IsoSurvey} includes
a sequence of preceeding edge labels in each element of the sequence. 

For temporal $r$-neighborhood subgraphs, we have more information that we can
use to prune the search space. The \textit{temporal profile} of an
$r$-neighborhood subgraph will be a tuple $p = (p_s,p_t)$ of the static profile and
some temporal information. This temporal information will be an interval
constructed from the intervals on the edges of graph. We will henceforth refer
to $p_S$ as the semantic profile, and $p_t$ as the profile interval.

\begin{defn}
  Define $\tau_f$ to be a curried folding function $\tau_f : \C \to P(T^2) \to T^2$,
  that summarizes a set of time intervals in a single time interval dependent on
  the temporal semantics. The cases are defined below:

  \[
    \tau_f(c)(S) = \begin{cases}
      \bigcap S, & \text{ if } c = \textsc{concur}, \\
      \bigcup S, & otherwise      
    \end{cases}
  \]
  
\end{defn}

This definition makes sense, since any temporal query that obeys the
concurrent implicit temporal semantics will need to match the intersection of
all of the activity windows of the edges, where if the query obeys the weak or
strong consecutive semantics, we will approximate the behavior by taking the
union of all the edges, i.e. the minimum start time and the maximum end
time. This will allow us to prune grossly errant results.

\begin{defn}
  The temporal profile $p$ of a graph $G = (V,E)$, given some contemporaneity condition
  $c \in \C$, is defined to be a tuple $(p_s, p_t)_c$ where
  \begin{itemize}
  \item $p_s$ \emph{\texttt{:=} \, \texttt{toSortedList}} \; $\{L(v) | v \in V \}$,
    and
  \item $p_t$ \emph{\texttt{:=} \, \texttt{foldr1}} \; $\tau_f(c)$ \; $\{T(e) | e \in E\}$, where
    \texttt{foldr1} accumulates $\tau_f(c)$ accross the  given set, assuming the set
    is non-empty. If the set is empty then let $p_t$ be $(\infty,\infty)$.
  \end{itemize}

  Given two temporal profiles $p = (p_s, p_t)$ and $p' = (p'_s, p'_t)$, $p$ is
  said to contain $p'$ with respect to a condition $c$ (denoted $p' \subseteq_c
  p$) if $p'_s$ is a subseqence of $p_s$, and $c.p(p_t, p'_t)$.
\end{defn}

Once we have this information, we will compare the temporal $r$-neighborhood
profiles of the query graph and the data graph. The semantic condition will be
that the query semantic profile must be a subsequence of the data semantic
profile, where the interval condition will just be that the intersection must be
nonempty.  If there is no query interval specified, then we will consider the
interval to be $(\infty, \infty)$. This local refinement is defined in Algorithm
\ref{alg:loc_ref}.

\begin{algorithm}
  \label{alg:loc_ref}
  \caption{\textsc{LocalRefinement(Q,G,$\Phi$, $r$, $c$)}}
  \SetAlgoLined
  \KwIn{A query graph $Q$, data graph $G$, current candidate sets $\Phi$, a
    radius $r$}
  \KwOut{A refined set of $\Phi$}

  \ForEach{$e \in E(Q)$}{
    Calculate the temporal profile $p$ of $N_c(Q,e,r)$\;
    \ForEach{$f \in \Phi(e)$}{
      Calculate the temporal profile $p'$ of $N_c(G,v,r)$\;
      \If{$p \not\subseteq p'$}{
        remove $f$ from $\Phi(e)$\; 
      }
    }
  }
\end{algorithm}

This \textsc{LocalRefinement} procedure is a part of the
\textsc{FilterCandidates} described in
Section~\ref{sec:naive_filter_candidates}.


