\section{Edge Isomorphism via Co-incidence Interval Graph}

In this section we want to enumerate the basics of the interval graph method by
expanding on the matches $h$ we defined above in Definition~\ref{defn:match}. 

We introduce the concept of the {\bf {\em co-incidence interval graph}, a
  derived static graph representing the temporal and incidence relationships
  between adjacent edges of a temporal graph. This interval graph is a lossless
  encoding (shown to be bijective) of the full temporal graph $G$, which allows
  us to run existing algorithms to find appropriate patterns.}

\begin{defn}
  \label{def:ci_graph}
  The co-incidence interval graph, $\I_G^c$ of a graph $G = (V_G,E_G, L_G)$ under
  implicit temporal constrain $c \in \impTC$, is a graph $\I_G^c = (E, \E)$, where its 
  node set is $E$,  the edge set of  graph $G$,  and it is edge set $\E \subseteq E^2$ is
  the set of ``meta-edges'' between elements in $E$. For any pair $e_1, e_e \in E$, 
  $(e_1,e_2) \in \E$ if  
  \begin{itemize}
    \item $e_1$ and $e_2$ share an endpoint, e.g., $\{\pi_1(e_1), \pi_2(e_1) 
    	\cap \pi_1(e_2), \pi_2(e_2) \not= \emptyset$,  and
    \item $\tau_B(c,\{e_1,e_2\}) = True$
  \end{itemize}
\end{defn}

The generic nature of this definition of the co-incidence interval graph accommodate any 
implicit temporal semantics defined earlier.

\todo[inline]{example}


 Let $I_c$ be the function that computes this co-incidence interval graph, given an implicit temporal constraint $c$, e.g., $I_c(G) \I_G^c$.

\begin{lemma}
  \label{lem:ci_biject}
  Given an implicit temporal constraint $c$, the function $I_c$ is a bijection over
  unlabelled\footnote{This is a trivial extension that only serves to complicate the proof. The lemma indeed holds for labelled graphs as well.} graphs $G$ with $\delta(G) \geq 1$.
\end{lemma}

\begin{proof}[Proof] Surjectivity follows the definition of function $I_c$, so,
  we will only show Injectivity.
  
  \textit{Injectivity}. All of the information necessary to restore the temporal
  graph $G$ is stored in the edge-set $E$, since there is no vertex that is not
  an endpoint of an edge. Thus, if $I_c(G) = I_c(H)$, then $V(I_c(G)) = E(G) =
  E(H) = V(I_c(H))$, hence $G = H$.
\end{proof}

\clearpage
\noindent \textbf{Remarks:}
\begin{itemize}
  \item Note that we didn't use the edge set of $\I^c_G$ at all in the proof
    above. This is because all of the structural information needed to describe
    the graph $G$ is stored in the edge set (labels are handled by an external
    map $L$).
  \item Note that Lemma~\ref{lem:ci_biject} only holds for graphs with
    $\delta(G) \geq 1$. This is because if there is a vertex that has degree
    zero, there is no edge that knows about it. This could be solved if you
    wanted to keep track of these vertices in $\I^c_G$. (Its also very unlikely
    for interesting large graphs for singletons to be of any use or
    importance. They will only be returned in trivial queries such as the empty
    graph or singletons).
\end{itemize}

\begin{corollary} Given temproal graphs $G$ and $H$ and a implia condition $c$, if there exists some
isomorphism $f_c : \I^c_G \to \I^c_H$, then $I_c^{-1} \circ f_c \circ I_c : G
\to H$ is also an isomorphism.
\end{corollary}

\reminder{need proof.}

Algorithm~\ref{alg:ci_graph} outlines the  construction of a coincidence interval 
graph. Its complexity  is $O(|E|d_{\max}(G))$ in the
edge-relational representation of the graph). 

Algorithm~\ref{alg:ci_graph_inv} depicts the procedure for restoring the original temporal graph given a co-incidence interval graph. 

\reminder{  it is not clear how the node labels are restored. }

\begin{algorithm}
  \label{alg:ci_graph}
  \caption{\textsc{MakeCoincidenceInterval($G$, $c$)}, equivalently $I_C(G)$}
  \SetAlgoLined
  \KwIn{A temporal graph $G = (V_G,E_G, L_G)$, a implicit temporal constraint $c$}
  \KwOut{The  coincidence interval graph $\I^c_G$}

  $\E = \emptyset$\;
  \ForEach{edge pair $e , f   \in E_G$}{
    \If{$\tau_B(c)(\{T(e),T(f)\})$}{
      Add meta-edge $(e,f)$ to $\E$\;
    }
  }
  \Return $(E_G, \E)$\;
\end{algorithm}

\begin{algorithm}
  \label{alg:ci_graph_inv}
  \caption{\textsc{UnmakeCoincidenceInterval($I_G^c$, $c$)}, equivalently $I_c^{-1}(\I_G^c)$ }
  \KwIn{The co-incidince interval graph $\I_G^c = (E, \E)$ }
  \KwOut{Temproal graph $G$}
  $E_G = E$\;
   $V_G = \emptyset$\;
  
  \ForEach{$e \in E_G$}{
    $V = V \cup \{\pi_1(e), \pi_2(e)\}$\;
  }
  \Return $(V_G,E_G)$\;
\end{algorithm}


