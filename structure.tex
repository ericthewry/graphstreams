\section{Implementation Structure}

Since Ullman's original search-space pruning algorithm published in 1976 there
has been an influx of new algorithms attempting to find tighter subspaces and
improved search orders, as well as storing partial results in graph indexes to
allow for faster access.  The most recent, and fastest algorithms have been in
the last 8 years. Notably, these are QuickSI, GraphQL, TurboIso, BoostIso, and
DualIso.

A 2012 comparison of existing algorithms concluded that QuickSI, and GraphQL
were the fastest from among other algorithms including GADDI, SPath, and
VF2. It created a common framework for all of the algorithms, that allowed for a
more comprehensive understanding of the way in which these graphs are being
queried. It is essentially broken up into four steps. \textsc{FilterCandidates},
which performs a label search on a given vertex.  Once this has been performed
for all vertices, the recursive subroutine \textsc{SubgraphSearch} is
called. Within this routine, there is the function \textsc{NextQueryVertex},
which determines the search order of the query graph, \textsc{IsJoinable}, which
determines whether the proposed match is actually viable, \textsc{UpdateState},
which updates the mapping with the joinable pair, then the recursive call, and finally,
\textsc{RestoreState}, which removes the pair from the mapping. This is
explicitly stated in Algorithm~\ref{alg:gen_query_proc}.

\begin{algorithm}
  \label{alg:gen_query_proc}
  \caption{\textsc{GenericQueryProc}$(Q,G)$}
  \SetAlgoLined
  \KwIn{A query graph $Q$, A data graph $G$}
  \KwOut{All subgraph ismorphisms of $Q$ in $G$}

  Initialize the Mapping $M$ to $\emptyset$\;
  \ForEach{$u \in V(Q)$}{
    $\Phi(u)$ \texttt{:=} \textsc{FilterCandidates}$(G,Q,u, \cdots )$\;
    \If{$\Phi(u) = \emptyset$}{ \Return{} \; }
  }

  \textsc{SubgraphSearch}$(Q,G,M,\Phi, \cdots)$\;

  \setcounter{AlgoLine}{0}
  \SetKwProg{subroutine}{Subroutine}{}{}
  \subroutine{\textsc{SubgraphSearch}$(Q,G,M,\Phi, \cdots)$}{
    \eIf{$|M| = |V(Q)|$}{
      \textbf{Report} $M$\;
    }{
      $u$ \texttt{:=} \textsc{NextQueryVertex} $(\cdots)$\;
      $\Phi'(u)$ \texttt{:=} \textsc{RefineCandidates} $(M,u, \Phi(u), \cdots)$\;
      \ForEach{$v \in \Phi'(u)$ that is not yet matched}{
        \If{\textsc{IsJoinable}$(Q,G,u,v, \cdots )$}{
          \textsc{UpdateState}$(M,u,v, \cdots )$\;
          \textsc{SubgraphSearch}$(Q,G,M, \cdots)$\;
          \textsc{RestoreState}$(M,u,v, \cdots )$\;
        }
      }
    }
  }
\end{algorithm}

In the next section we will detail how to go about developing this framework for
existing graphs. Specifically, how we can use temporal information to further
restruct the search space for existing algorthmic paradigms.
